///
/// CallbackHolder.swift
/// Thu Aug 29 2024
/// This file was generated by nitrogen. DO NOT MODIFY THIS FILE.
/// https://github.com/mrousavy/nitro
/// Copyright Â© 2024 Marc Rousavy @ Margelo
///

import NitroModules

/**
 * Represents an instance of `CallbackHolder`, backed by a C++ struct.
 */
public typealias CallbackHolder = margelo.nitro.image.CallbackHolder

public extension CallbackHolder {
  private typealias bridge = margelo.nitro.image.bridge.swift

  /**
   * Create a new instance of `CallbackHolder`.
   */
  init(callback: @escaping (() -> Void)) {
    self.init({ () -> bridge.Func_void in
      class ClosureHolder {
        let closure: (() -> Void)
        init(wrappingClosure closure: @escaping (() -> Void)) {
          self.closure = closure
        }
        func invoke() {
          self.closure()
        }
      }
    
      let closureHolder = Unmanaged.passRetained(ClosureHolder(wrappingClosure: callback)).toOpaque()
      let call: @convention(c) (UnsafeMutableRawPointer?) -> Void = { closureHolder in
        let closure = closureHolder!.assumingMemoryBound(to: ClosureHolder.self).pointee
        closure.invoke()
      }
      let destroy: @convention(c) (UnsafeMutableRawPointer?) -> Void = { closureHolder in
        guard let closureHolder else { fatalError("ClosureHolder was released twice!") }
        Unmanaged<ClosureHolder>.fromOpaque(closureHolder).release()
      }
    
      return bridge.create_Func_void(closureHolder, call, destroy)
    }())
  }

  var callback: (() -> Void) {
    @inline(__always)
    get {
      return { () -> Void in
        self.__callback()
      }
    }
    @inline(__always)
    set {
      self.__callback = { () -> bridge.Func_void in
        class ClosureHolder {
          let closure: (() -> Void)
          init(wrappingClosure closure: @escaping (() -> Void)) {
            self.closure = closure
          }
          func invoke() {
            self.closure()
          }
        }
      
        let closureHolder = Unmanaged.passRetained(ClosureHolder(wrappingClosure: newValue)).toOpaque()
        let call: @convention(c) (UnsafeMutableRawPointer?) -> Void = { closureHolder in
          let closure = closureHolder!.assumingMemoryBound(to: ClosureHolder.self).pointee
          closure.invoke()
        }
        let destroy: @convention(c) (UnsafeMutableRawPointer?) -> Void = { closureHolder in
          guard let closureHolder else { fatalError("ClosureHolder was released twice!") }
          Unmanaged<ClosureHolder>.fromOpaque(closureHolder).release()
        }
      
        return bridge.create_Func_void(closureHolder, call, destroy)
      }()
    }
  }
}
